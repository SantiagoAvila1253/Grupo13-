1. Objetivo general

El sistema gestiona el presentismo de los alumnos de una única comisión.
Las funciones principales del sistema son:

Registrar la asistencia de cada alumno en cada clase.

Calcular el porcentaje de asistencia de cada alumno.

Aplicar la baja automática de alumnos que superen el 25% de inasistencias injustificadas.

Generar reportes de control (por alumno, por clase, generales).

Controlar el acceso mediante docentes autenticados.

El sistema se implementa en Python y utiliza persistencia en archivos JSON y CSV.

2. Modelo de datos

El sistema no usa una base de datos relacional ni variables globales como “fuente de verdad”.
En cambio, toda la información persistente vive en archivos dentro de la carpeta data/.

2.1 Archivos JSON

La información estructural y de referencia (alumnos, clases, docentes) se guarda en tres archivos JSON separados:

data/alumnos.json

data/clases.json

data/docentes.json

Cada archivo JSON es un diccionario de diccionarios, indexado por la clave primaria de esa entidad (legajo de alumno, id de clase, id de docente).

Ejemplo de data/alumnos.json:

{
  "30001": {
    "legajo": 30001,
    "apellido": "Saltid",
    "nombre": "Juan",
    "dni": "40111222",
    "nacimiento": "2007-09-08",
    "mail": "jsaltid@uade.edu.ar",
    "% asistencia": 0.00,
    "activo": true
  },

  "30002": {
    "legajo": 30002,
    "apellido": "Altanio",
    "nombre": "Pablo",
    "dni": "39222333",
    "nacimiento": "2004-04-19",
    "mail": "paltanio@uade.edu.ar",
    "% asistencia": 0.00,
    "activo": true
  }

  /* ... resto ... */
}


Características importantes:

La clave externa "30001", "30002", etc. es el legajo del alumno convertido a string.

Cada alumno tiene además el campo "legajo" repetido adentro, como entero. Esto deja el registro autocontenido.

Los legajos de alumnos empiezan en 30000.

% asistencia siempre se guarda con dos decimales (ej: 87.50).

"activo": true significa que el alumno sigue participando de la cursada. Si pasa a false, deja de aparecer en tomas de asistencia nuevas.

Ejemplo de data/clases.json:

{
  "20001": {
    "id_clase": 20001,
    "materia": "Matemática",
    "fecha": "2025-08-05",
    "dia": "Martes",
    "horario": "14:00 - 18:00"
  },

  "20002": {
    "id_clase": 20002,
    "materia": "Matemática",
    "fecha": "2025-08-12",
    "dia": "Martes",
    "horario": "14:00 - 18:00"
  }

  /* ... resto de clases ... */
}


Características:

Los IDs de clase comienzan en 20000.

Las clases están predefinidas: el sistema no da de alta nuevas clases en tiempo de ejecución.

Cada clase incluye día, horario y fecha para mostrar y para reportes.

Ejemplo de data/docentes.json:

{
  "10000": {
    "id_docente": 10000,
    "dni/usuario": "12345678",
    "clave": "Clave.123",
    "nombre": "Carlos",
    "apellido": "Gonzalez",
    "mail": "cgonzalez@uade.edu.ar",
    "activo": true
  }
}


Características:

Los IDs de docente comienzan en 10000.

Este archivo se usa para autenticación (inicio de sesión).

El docente debe estar "activo": true para poder ingresar.

Justificación del diseño JSON

Separar alumnos.json, clases.json y docentes.json en lugar de tener un único sistema.json tiene beneficios claros:

Eficiencia de carga: cada funcionalidad lee solo el archivo que necesita. Por ejemplo, para tomar asistencia no es necesario cargar los docentes.

Escalabilidad: la cantidad de clases puede crecer mucho más que la cantidad de docentes. Mantenerlas separadas evita cargar en memoria información que no se está usando.

Cohesión: cada archivo representa una entidad lógica del dominio. Esto facilita mantenimiento y reduce errores.

Acceso directo por ID: al ser diccionario de diccionarios, acceder a un alumno, clase o docente por ID es O(1) usando la clave:

alumno = alumnos_json["30012"]
clase = clases_json["20003"]


Esto nos permite demostrar, desde la materia, que:

en JSON trabajamos fuertemente con diccionarios anidados e indexados;

en CSV trabajamos con listas/filas (ver siguiente sección).

2.2 Archivo CSV

El historial de asistencia se guarda en data/asistencia.csv.

Este archivo representa datos transaccionales: cada marca de presente/ausente.

Es una lista ordenada de filas, no un diccionario.

Formato (cabecera fija):

clase_id;legajo;apellido;nombre;estado


Ejemplo de filas:

20001;30001;Saltid;Juan;P
20001;30002;Altanio;Pablo;AI
20002;30001;Saltid;Juan;AJ
20002;30002;Altanio;Pablo;P
20003;30015;Flores;Faustina;P


Significado de estado:

P → presente

AI → ausente injustificado

AJ → ausente justificado

"" → vacío (todavía no marcado)

Reglas del CSV:

Cada fila representa un alumno en una clase.

El archivo va creciendo con el tiempo. Nunca se borran filas anteriores.

Las filas se agregan en orden cronológico (por clase).

Alumnos inactivos quedan en el histórico pero no se muestran en futuras tomas.

Este CSV nos permite practicar:

manejo de listas de registros,

lectura línea por línea,

filtrado por clase o por alumno,

y escritura selectiva (actualizar solo una clase sin reescribir todo).

3. Flujo de toma de asistencia
Paso 1. Selección de clase

El docente elige la clase usando su id_clase (por ejemplo 20003).

Paso 2. Sincronización previa

Antes de marcar asistencia, el sistema hace una sincronización en memoria:

Lee clases.json para validar que la clase existe y obtener la fecha/horario.

Lee alumnos.json y obtiene todos los alumnos con "activo": true.

Lee asistencia.csv y busca todas las filas que ya existan para esa id_clase.

Para cada alumno activo:

Si ya tiene una fila en el CSV para esa clase, se usa esa fila (pero se actualizan apellido y nombre en memoria por si cambiaron en alumnos.json).

Si NO tiene fila todavía para esa clase, se genera en memoria una fila nueva con:

clase_id = id_clase seleccionado

legajo = legajo del alumno

apellido, nombre tomados del JSON (actualizados)

estado = "" (sin marcar todavía)

Alumnos que están "activo": false en alumnos.json no aparecen en la lista a marcar, aunque queden en el histórico.

La lista resultante se ordena al mostrarla (ej. por apellido), pero esa ordenación es solo en memoria. El CSV en disco se mantiene cronológico.

En términos de la materia:

Acá se ve lectura combinada de diccionarios (JSON) y lectura/recorrido de listas (CSV).

También aparece la idea de “sincronización” entre fuentes de datos persistentes.

Paso 3. Registro

El docente ingresa P, AI o AJ para cada alumno listado.

Paso 4. Guardado

Al confirmar:

Se reescriben/actualizan en asistencia.csv solamente las filas que pertenecen a esa id_clase.

No se guarda automáticamente sin confirmación.

Si el docente cancela, el CSV queda igual que antes.

4. Cálculo de asistencia y baja automática
4.1 Cálculo de asistencia

Para cada alumno:

Se cuenta cuántas clases totales existen.
Eso es simplemente la cantidad de keys en clases.json.

Se cuenta cuántas veces ese alumno aparece con estado == "P" en asistencia.csv.

Se calcula el porcentaje de asistencia:

% asistencia = (presentes / total_clases) * 100


Ese valor, redondeado a dos decimales, se guarda en alumnos.json dentro del campo "% asistencia".

Ejemplo:

"% asistencia": 87.50

4.2 Regla del 25%

También se evalúa el porcentaje de inasistencias injustificadas:

Se cuentan las filas donde estado == "AI".

Se calcula (AI / total_clases) * 100.

Si ese porcentaje supera el 25 %:

El alumno se marca "activo": false en alumnos.json.

Ese alumno deja de ser mostrado en tomas de asistencia futuras.

El histórico previo en el CSV se conserva.

Esto es una baja lógica, no física.
No se elimina el alumno del sistema: simplemente deja de participar activamente.

5. Módulos del sistema
5.1 Capa core/

Esta capa maneja infraestructura y lógica global.

core/es_json.py

Lectura y escritura de alumnos.json, clases.json, docentes.json.

Operaciones CRUD lógicas sobre alumnos (alta, modificación, baja lógica).

Actualización del campo "% asistencia" y del campo "activo".

core/es_csv.py

Lectura y escritura de asistencia.csv.

Filtrado por id_clase.

Actualización de las filas de una clase específica sin tocar el resto.

core/estadisticas.py

Cálculo de % asistencia.

Detección de alumnos que superan el 25 % de inasistencias injustificadas.

Aplicación de la baja lógica automática.

core/validadores.py

Validaciones de entradas (por ejemplo, legajos válidos, formato de fecha, estado de asistencia permitido).

core/helpers.py

Utilidades comunes de formato, ordenamiento, normalización de strings, etc.

core/menus.py

Maneja la interacción por consola: menús de opciones, navegación del usuario docente.

core/datos.py

Constantes globales útiles para la app (por ejemplo, mapeos simbólicos como P, AI, AJ, etc.).

Ya no guarda los datos maestros (eso vive en JSON/CSV, no en memoria dura acá).

5.2 Capa funcionalidades/

Esta capa implementa los “casos de uso” que el docente realmente ejecuta.

funcionalidades/alumnos.py

Alta/modificación de alumnos.

Cambios en el estado "activo" (baja lógica).

Usa es_json.py.

funcionalidades/asistencia.py

Sincronización previa de una clase.

Toma de asistencia.

Confirmación de guardado en CSV.

Usa es_json.py + es_csv.py.

funcionalidades/reportes.py

Reporte por alumno (asistencia, estado).

Reporte por clase (quién asistió / faltó).

Reporte general.

Usa es_json.py, es_csv.py, estadisticas.py.

5.3 Capa login/

login/autenticacion.py

Verifica credenciales del docente contra docentes.json.

Solo permite acceder si el docente está activo.

5.4 Pruebas

tests/tests_unitarios.py

Debe incluir al menos tres tests unitarios obligatorios.

Casos típicos que se prueban:

Lectura y escritura correcta de JSON.

Lectura y reescritura correcta del bloque de una clase en asistencia.csv.

Aplicación de la regla del 25 % y baja lógica.

6. Principios de diseño que justifican la implementación

Separación por entidad:
alumnos.json, clases.json, docentes.json viven separados para reducir el peso de lectura en memoria.
Esto es importante cuando crece el número de clases (potencialmente muchas) o de registros históricos.

Diccionario de diccionarios en JSON:
Cada archivo JSON es un diccionario indexado por ID (ej. "30001") y cada valor es otro diccionario con los campos de esa entidad.
Esto demuestra el uso de estructuras clave → valor (diccionarios) y acceso directo por clave primaria:

alumnos["30012"]["activo"] = False


CSV como matriz histórica:
asistencia.csv es tratado como una lista cronológica de registros.
Eso permite practicar manejo de listas / filas / recorridos secuenciales.

Sin guardado automático:
La aplicación siempre pregunta si se quiere guardar.
Si el usuario decide “salir sin guardar”, no se vuelca al archivo.
Eso evita estados parciales y es fácil de explicar en la defensa.

Baja lógica, no física:
El alumno nunca se borra completamente.
Se marca "activo": false en el JSON, y se deja de mostrar en la toma de asistencia futura.
Esto permite mantener coherencia con el histórico del CSV sin reescribirlo.